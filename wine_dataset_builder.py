# -*- coding: utf-8 -*-
"""wine_data

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SsOhNK0mQmDWLGTr1jtiaJCPQ3-VWV71
"""

!pip install ace_tools

!pip install python-dotenv

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import os
import re
import random
from googleapiclient.discovery import build
from google.oauth2 import credentials
from dotenv import load_dotenv

load_dotenv()

BASE_URL = os.getenv("CATALOG_BASE_URL")

folder_path = os.getenv("IMAGE_FOLDER_PATH", "images/")
file_list = os.listdir(folder_path)

file_data = []
for file in file_list:
    if file.endswith(('.png')):  # Filter image files only
        file_url = f"{BASE_URL}{file}" # Format Google Drive URL
        file_data.append([file, file_url])

df = pd.DataFrame(file_data, columns=["File Name", "URL"])
df.head()

df.info()

df['File Name'] = df['File Name'].str.strip(".png")

df['File Name'] = df['File Name'].str.replace("_", " ")

unique_first_words = set()

for item in df['File Name']:
  first_word = item.split()[0]
  unique_first_words.add(first_word)

print(unique_first_words)

df['File Name'] = df['File Name'].str.lstrip('Вино')

def extract_volume(file_name):
    match = re.search(r'(\d+(\.\d+)?)л', file_name)  # Extract number followed by 'л' (liters)
    return match.group(1) if match else None  # Return the number if found, otherwise return None

# Apply to the entire column
df["Capacity"] = df["File Name"].apply(extract_volume)

# Remove volume from the name (to avoid duplication)
df["File Name"] = df["File Name"].str.replace(r'(\d+(\.\d+)?)л', '', regex=True)

df.head()

def assign_grape_variety(df):
    """
    Checks the 'File Name' column for the presence of words from the grape list
and adds the corresponding value to the 'grape' column.

Args:
    titles: DataFrame with a 'File Name' column.

Returns:
    DataFrame with an added 'grape' column.
    """

    grape = ['Bordeaux Blend Red',
             'Cabernet Sauvignon',
             'Chardonnay',
             'Chenin Blanc',
             'Gewurztraminer',
             'Malbec',
             'Merlot',
             'Nebbiolo',
             'Pinot Gris',
             'Pinot Grigio',
             'Pinot Noir',
             'Riesling',
             'Sangiovese',
             'Sauvignon Blanc',
             'Shiraz',
             'Syrah',
             'Tempranillo']

    df['grape'] = ''  # Create a new column and initialize it with empty values

    for index, row in df.iterrows():
        file_name = row['File Name']
        for variety in grape:
            # Use regular expression to search for the word in any case
            if re.search(r'\b' + re.escape(variety) + r'\b', file_name, re.IGNORECASE):
                df.loc[index, 'grape'] = variety
                break  # Skip to the next file if the grape variety has already been found

    return df

"""Bordeaux
Blend Red
Cabernet
Sauvignon
Chardonnay
Chenin Blanc
Gewurztraminer
Malbec
Merlot
Nebbiolo
Pinot Gris/Grigio
Pinot Noir
Riesling
Sangiovese
Sauvignon Blanc
Shiraz
Syrah
Tempranillo
"""

df.head()

# Example list of grape varieties (can be extended based on collected data)
grape_varieties = [
    'Cabernet Sauvignon', 'Merlot', 'Chardonnay', 'Riesling', 'Sauvignon Blanc',
    'Pinot Noir', 'Syrah', 'Zinfandel', 'Malbec', 'Sangiovese', 'Gewürztraminer',
    'Grenache', 'Tempranillo', 'Mourvèdre', 'Barbera', 'Nebbiolo', 'Viognier',
    'Muscat', 'Gamay', 'Carmenere', 'Pinot_Grigio', 'Semillon', 'Torrontes',
    'Albarino', 'Verdejo', 'Gruner Veltliner', 'Fiano', 'Arneis', 'Cortese',
    'Trebbiano', 'Lambrusco', 'Touriga Nacional', 'Tannat', 'Petit Verdot',
    'Petite Sirah', 'Marsanne', 'Roussanne', 'Carignan', 'Cinsault', 'Dolcetto',
    'Primitivo', 'Nero d Avola', 'Aglianico', 'Montepulciano', 'Negroamaro',
    'Verdicchio', 'Soave', 'Frascati', 'Orvieto', 'Prosecco', 'Brunello',
    'Vernaccia', 'Valpolicella', 'Amarone', 'Bardolino', 'Cava', 'Sherry',
    'Port', 'Madeira', 'Marsala'
]


# Create a new 'Grape' column with initial values set to None
df['Grape'] = None

# Function to check and fill the 'Grape' column
def identify_grape_variety(file_name):
    for grape in grape_varieties:
        if grape in file_name:
            return grape.replace('_', ' ')
    return None

# Apply the function to the 'File Name' column
df['Grape'] = df['File Name'].apply(identify_grape_variety)

df.head()

# Function to identify the value variety
def identify_or_assign_by_keyword(file_name, current_value, keyword, current_list):
      # If value is already identified — keep it
    if pd.notna(current_value):
        return current_value

    # Check if the key word is present (case-insensitive)
    if keyword in file_name.lower():
        return random.choice(current_list)  # Random choise from current list

    return None  # If no value variety is found

# Create the current list wite grape varieties
white_grape_varieties = [
    'Chardonnay', 'Riesling', 'Sauvignon Blanc', 'Gewürztraminer', 'Viognier',
    'Muscat', 'Pinot Grigio', 'Semillon', 'Torrontes', 'Albarino', 'Verdejo',
    'Gruner Veltliner', 'Fiano', 'Arneis', 'Cortese', 'Trebbiano', 'Verdicchio',
    'Soave', 'Frascati', 'Orvieto', 'Prosecco', 'Vernaccia'
]

# Apply the function identify_or_assign_by_keyword to the 'Grape' column
df["Grape"] = df.apply(
    lambda row: identify_or_assign_by_keyword(
        row["File Name"],
        row["Grape"],
        "біле",
        white_grape_varieties
    ),
    axis=1
)

red_grape_varieties = [
    'Cabernet Sauvignon',
    'Merlot',
    'Pinot Noir',
    'Syrah',
    'Zinfandel',
    'Malbec',
    'Sangiovese',
    'Grenache',
    'Tempranillo',
    'Mourvèdre',
    'Barbera',
    'Nebbiolo',
    'Gamay',
    'Carmenere',
    'Lambrusco',
    'Touriga Nacional',
    'Tannat',
    'Petit Verdot',
    'Petite Sirah',
    'Marsanne',
    'Roussanne',
    'Carignan',
    'Cinsault',
    'Dolcetto',
    'Primitivo',
    'Nero d Avola',
    'Aglianico',
    'Montepulciano',
    'Negroamaro',
    'Brunello',
    'Valpolicella',
    'Amarone',
    'Bardolino',
    'Cava',
    'Sherry',
    'Port',
    'Madeira',
    'Marsala'
]

# Apply the function to the 'Grape' column
df["Grape"] = df.apply(
    lambda row: identify_or_assign_by_keyword(
        row["File Name"],
        row["Grape"],
        "червоне",
        red_grape_varieties
    ),
    axis=1
)

rose_grape_varieties = [
    "Grenache",
    "Cinsault",
    "Mourvèdre",
    "Tempranillo",
    "Gamay",
    "Pinot Noir",
    "Syrah",
    "Zinfandel",
    "Sangiovese",
    "Barbera",
    "Nebbiolo",
    "Nero d'Avola",
    "Montepulciano",
    "Negroamaro"
]

# Apply the function to the 'Grape' column
df["Grape"] = df.apply(
    lambda row: identify_or_assign_by_keyword(
        row["File Name"],
        row["Grape"],
        "рожеве",
        rose_grape_varieties
    ),
    axis=1
)
# Check the results
df.head()

def assign_wine_items(df):
      # Dictionary for identifying the wine type
    wine_type = {
        'біле': 'White',
        'червоне': 'Red',
        'рожеве': 'Rose'
    }
      # Dictionary for identifying the wines country
    wine_country = {
        'Espaniola': 'Spain',
        'Italianica': 'Italy',
        'Geo': 'Georgia',
        'Inglenook' : 'England',
        'Los' : 'Argentina',
        'Las' : 'Argentina',
        'Frontera' : 'Chile',
        'Sunrise' : 'Chile',
        'Casillero' : 'Chile',
        'Aphros' : 'Portugal',
        'Noval' : 'Portugal',
        'Verite' : 'USA',
        'Jack' : 'USA',
        'Echo' : 'USA'
    }

    # Function to identify the wine items
    def find_wine_items(file_name, current_dict):
        for keyword, current_dict_value in current_dict.items():
            if re.search(r'\b' + re.escape(keyword) + r'\b', file_name, re.IGNORECASE):
                return current_dict_value
        return None  # If no keywords are found


    # Apply the function find_wine_items to 'type' column
    df['type'] = df['File Name'].apply(lambda x: find_wine_items(x, wine_type))

    # Apply the function find_wine_items to 'country' column
    df['country'] = df['File Name'].apply(lambda x: find_wine_items(x, wine_country))

    return df

# Call the function for the dataset
df = assign_wine_items(df)

df.head()

print(df['country'].unique)

print(df['country'].isnull().sum())

country_varieties = [
    'Spain',
    'USA',
    'New Zealand',
    'France',
    'Italy',
    'Portugal',
    'Greece',
    'Australia',
    'England',
    'Argentina',
    'Chile',
    'South Africa',
    'Austria',
    'Lebanon',
    'Germany',
    'Serbia',
    'Moldova',
    'Hungary',
    'Slovenia',
    'Romania',
    'Georgia',
    'Bulgaria'
]

# Apply the function identify_or_assign_by_keyword to the 'Grape' column
df["country"] = df.apply(
    lambda row: identify_or_assign_by_keyword(
        row["File Name"],
        row["country"],
        "вино", # Using the identify_or_assign_by_keyword function to fill missing values in the 'country' column.
# The keyword argument is set to "вино" ("wine"), as this word appears in every row —
# the keyword check does not affect the logic but allows reuse of the existing function without modification.
        country_varieties
    ),
    axis=1
)

print(df['country'].isnull().sum())

def assign_wine_region(df):
    # Dictionary for identifying the region
    wine_region = {
        'Argentina': ['Mendoza', 'San Juan'],
        'Austria' : ['Burgenland', 'Lower Austria', 'Styria', 'Vienna'],
        'Australia': ['New South Wales', 'South Australia', 'South East Australia', 'Tasmania', 'Victoria', 'Western Australia'],
        'Bulgaria': 'Bulgaria',
        'Chile' : ['Aconcagua', 'Central Valley', 'North', 'Chile'],
        'France' : ['Alsace', 'Beaujolais', 'Bordeaux', 'Bourgogne', 'Burgundy', 'Corsica', 'Dordogne', 'Limoux', 'Provence'],
        'England' : ['Hampshire', 'Kent', 'Surrey', 'Sussex'],
        'Georgia' : 'Kvareli',
        'Germany' : 'Germany',
        'Greece' : 'Greece',
        'Hungary' : 'Hungary',
        'Italy' : ['Basilicata', 'Abruzzo', 'Campania', 'Le Marche', 'Lombardy', 'Piedmont', 'Veneto'],
        'Lebanon' : 'Lebanon',
        'Moldova' : 'Moldova',
        'New Zealand' : ['Central Otago', 'Gisborne', 'Hawkes Bay', 'Marlborough', 'Martinborough', 'Nelson', 'Waipara'],
        'Portugal' : ['Alentejo', 'Dao', 'Douro'],
        'Romania' : 'Romania',
        'Serbia' : 'Serbia',
        'Slovenia' : 'Slovenia',
        'South Africa' : ['Coastal', 'Constantia', 'Elgin', 'Franschhoek', 'Robertson', 'Swartland'],
        'Spain' : ['Aragon', 'Castilla Y León', 'Castilla-La Mancha', 'Catalunya', 'Galicia'],
        'USA' : ['California', 'Oregon']
    }

    # Function to determine wines region
    def find_wine_region(file_name):
        for keyword, wine_region_value in wine_region.items():
            if re.search(r'\b' + re.escape(keyword) + r'\b', file_name, re.IGNORECASE):
                return random.choice(wine_region_value)
        return None  # If no keywords are found

    # Apply the function to the entire DataFrame
    df['region'] = df['country'].apply(find_wine_region)

    return df

# Call the function for the dataset
df = assign_wine_region(df)

df.head()

print(df['File Name'].unique())

def extract_vintage(df):
    """
   Extracts the year (19xx or 20xx) from the wine name and fills the 'vintage' column.

Args:
    df: DataFrame with the 'File Name' column.

Returns:
    DataFrame with the added 'vintage' column.
    """
    # Function to extract the year from the file name
    def find_vintage(file_name):
        match = re.search(r'\b(19\d{2}|20\d{2})\b', str(file_name))  # Search for the year (19xx or 20xx)
        return match.group(1) if match else None  # If not found

    # Apply the function to the entire column
    df["vintage"] = df["File Name"].apply(find_vintage)

    return df

# Call the function for the dataset
titels = extract_vintage(df)

df.head()
#print(df['vintage'].isnull().sum())

import numpy as np

vintage_varieties = range(1998, 2025)



# Function to determine vintage variety
def identify_or_assign_vintage(file_name, current_vintage):
    # If the vintage variety is already identified — leave it unchanged
    if pd.notna(current_vintage):
        return current_vintage

    else:
        return random.choice(vintage_varieties)  # Random vintage variety



# Apply the function to the entire column
df["vintage"] = df.apply(lambda row: identify_or_assign_vintage(row["File Name"], row["vintage"]), axis=1)

closure =['Natural Cork', 'Screwcap']
df['closure'] = random.choice(closure)

wine_tasting_notes = [
    "red fruit", "black fruit", "spice", "oak", "citrus", "green apple",
    "minerals", "flowers", "tropical fruit", "honey", "ginger", "nuts",
    "red berries", "earth", "mushrooms", "tobacco", "black currant", "vanilla",
    "chocolate", "mint", "plum", "cinnamon", "clove", "violet", "peach",
    "apricot", "honeysuckle", "almond", "pear", "quince", "lemon zest", "flint",
    "pineapple", "mango", "passion fruit", "coconut", "raspberry", "strawberry",
    "cherry", "chocolate", "blackberry", "blueberry", "mulberry", "pepper",
    "grape", "fig", "date", "raisin", "grass", "hay", "green pepper", "asparagus",
    "coffee", "caramel", "vanilla", "oak", "chocolate", "tobacco", "leather",
    "earth", "flowers", "perfume", "incense", "minerals", "spice", "pepper",
    "clove", "cinnamon", "nuts", "almond", "hazelnut", "peanut", "honey", "wax",
    "propolis", "sweetness", "fruit", "berries", "flowers", "spice"
]
def get_characteristics(x):
    if isinstance(x, list):  # If it's a list, just join with commas
        return ', '.join(x)
    elif pd.isna(x) or x == "":  # If the value is empty or NaN — generate a new one
        return ', '.join(random.choices(wine_tasting_notes, k=3))
    else:
        return x  # If it's already a string, leave it as is
df['Characteristics'] = ''
# Update the 'Characteristics' column
df['Characteristics'] = df['Characteristics'].apply(get_characteristics)

# Check the result
print(df[['Characteristics']].head(10))

style = [
    'Rich & Juicy',
    'Rich & Toasty',
    'Crisp & Zesty',
    'Ripe & Rounded',
    'Smooth & Mellow',
    'Light & Refreshing',
    'Crisp & Fruity',
    'Fresh & Elegant',
    'Delicate & Dry',
    'Bold & Spicy',
    'Savoury & Full Bodied',
    'Soft & Fruity',
    'Aromatic & Floral',
    'Smooth & Light',
    'Ripe & Fruity',
    'Light & Elegant'
]
def get_style():
    return random.choice(style)

df['style'] = df.apply(lambda row: get_style(), axis=1)

def assign_random_price(df):
    n = len(df)  # Number of rows
    df['price'] = np.where(np.random.rand(n) < 0.5,  # Condition: the number will be float or int
                           np.random.uniform(5, 59, size=n),  # Random floats
                           np.random.randint(5, 60, size=n))  # Random ints (up to 59 inclusive)
    return df



# Call the function without apply
df = assign_random_price(df)

# Check the result
print(df)

# Function to determine the wine category
def categorize_wine(name):
    name = name.lower()  # Convert to lowercase

    if any(word in name for word in ["червоне", "red", "rosso", "rouge"]):
        return "red"
    elif any(word in name for word in ["біле", "white", "blanco", "bianco"]):
        return "white"
    elif any(word in name for word in ["ігристе", "sparkling", "brut", "prosecco"]):
        return "sparkling"
    elif any(word in name for word in ["десертне", "dessert", "porto", "sherry", "muscat"]):
        return "dessert"
    else:
        return "unknown"

# Add the 'wine_type' column
df["wine_type"] = df["File Name"].apply(categorize_wine)

df.head()

# Function to round ABV to the nearest .5 value
def round_to_nearest_half(value):
    return round(value * 2) / 2  # Округлюємо до 0.5

# Function to generate a random ABV rounded to .5
def generate_abv(wine_type):
    ranges = {
        "red": (12, 15),
        "white": (11, 14),
        "sparkling": (10, 12.5),
        "dessert": (15, 22),
        "unknown": (11, 15)  # Average value for all wines
    }

    abv_range = ranges.get(wine_type, (11, 15))
    return round_to_nearest_half(np.random.uniform(*abv_range))

# Add new ABV values rounded to .5
df["ABV"] = df["type"].apply(generate_abv)
df["ABV"] = df["ABV"].astype(str) + "%"

# Check the result
print(df[["File Name", "type", "ABV"]].head(10))

def clean_wine_name(name):
   # Remove unnecessary Ukrainian words
    words_to_remove = ["вино біле", "вино червоне", "вино рожеве"]
    for word in words_to_remove:
        name = name.replace(word, "").strip()

    # Remove volume information (0.75l, 1.5l, 750ml, etc.)
    name = re.sub(r"\d+(\.\d+)?\s?(л|ml)", "", name, flags=re.IGNORECASE)

    return name.strip()

# Clean the 'File Name' column
df["Title"] = df["File Name"].apply(clean_wine_name)

# Check the result
print(df[["File Name", "Title"]].head(5))

print(df.isnull().sum())

df[df.isna().any(axis=1)]

def generate_wine_description_en(row):
    """Generates a wine description in English based on its attributes"""
    name = row["Title"]  # Using the cleaned name without unnecessary words
    grape = row["Grape"]
    country = row["country"]
    region = row["region"]
    vintage = row["vintage"]
    characteristics = row["Characteristics"]
    style = row["style"]
    abv = row["ABV"]

    # Formatting the description
    description = (
        f"{name} ({grape}) is a refined {row['wine_type'].lower()} wine from {country}, "
        f"specifically the {region} region. Produced from the {vintage} vintage, it offers "
        f"flavors of {characteristics} and is best described as {style}. Alcohol content: {abv}."
    )

    return description

# Adding English descriptions to the DataFrame
df["description"] = df.apply(generate_wine_description_en, axis=1)

# Checking the result
print(df[["Title", "description"]].head(5))

df = df.dropna(subset=["type"])

df["price"] = df["price"].round(2)
df["price"] = df["price"].apply(lambda x: f"${x:.2f}")

df = df.drop(columns="File Name")

# New columns order

columns_order = ["Title", "description", "price", "Capacity",  "Grape", "closure", "country", "Characteristics", "type", "ABV", "region", "style", "vintage"
                 ]
df = df.reindex(columns=columns_order)

# Checking the result
df.head()

df.to_csv("data/final_data.csv", index=False)